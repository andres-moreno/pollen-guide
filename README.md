# A poor guide to Pollen
The [official Pollen documentation](pkg-build.racket-lang.org/doc/pollen/) is a rich and hearty repast. That may be why it took me longer than expected to get where I wanted to go.

So, here's a poor and meagre introduction that may help others get started as quickly as possible.

## Goal
I'm trying to write Pollen markup that generates Dave Liepmann's [Tufte CSS](http://www.daveliepmann.com/tufte-css/)-compliant HTML. Tufte CSS has some nice rules for sidenotes and headings that I'd like to write for, without writing HTML.

## Preliminaries
Install [Racket](http://download.racket-lang.org/)

> On **Mac OS X**, verify the installation location by running `$ /Applications/Racket\ v6.2.1/bin/racket -v`, then add the following to your `~/.bash_profile`: 
```bash
export PATH="$PATH:/Applications/Racket v6.2.1/bin"
```

Then install Pollen by running `$ raco pkg install pollen` and answering "yes" a couple of times.

Now. After reading portions of [three](http://pkg-build.racket-lang.org/doc/pollen/first-tutorial.html) [longform](http://pkg-build.racket-lang.org/doc/pollen/second-tutorial.html) [tutorials](http://pkg-build.racket-lang.org/doc/pollen/third-tutorial.html) ([fourth](http://pkg-build.racket-lang.org/doc/pollen/fourth-tutorial.html) available), a [mini-tutorial](http://pkg-build.racket-lang.org/doc/pollen/mini-tutorial.html), and a [quick tour](http://pkg-build.racket-lang.org/doc/pollen/quick-tour.html), you will likely be very excited about many things. But for purposes of this poor guide, you can forget everything about DrRacket, `.pp` Pollen preprocessor files, `.pmd` & Pollen-Markdown mode, the Pollen project server (`raco pollen start`), etc.

We'll be writing Pollen markup directly in `.html.pm` files, rendering them from the command line with `raco pollen render`, and viewing just the result in a browser. Clone this repository and follow along.

**N.B.** I'm assuming you have some passing familiarity with the Lisp family, from Common Lisp or Emacs Lisp or Scheme or Clojure or somewhere. The examples that follow have enough weird Pollen awesomeness that I can't stop and explain symbols or [`,@ unquote-splicing`](http://docs.racket-lang.org/guide/qq.html). But I will try to point out Racketisms to save you some Googling, though it's always a good idea to [Learn X=Racket in Y Minutes](http://learnxinyminutes.com/docs/racket/).

## Take One. Basic and not-so-basic functionality.
In the `take1/` directory there are
- two input files: Pollen markup in `take1.html.pm` and an HTML template `template.html`,
- one helper file: the `tufte.css` file from Liepmann, and
- out output file: `take1.html` which is generated by running `raco pollen render take1.html`.


The reason you could forget about Markdown and the Pollen preprocessor is because these are small fry compared to real Pollen markup. Compare the Pollen markup input and its rendered output:

<img width="1482" alt="take1-screenshot" src="https://cloud.githubusercontent.com/assets/37649/9675781/2c032492-5290-11e5-9a88-68aacc828ab3.png">

In the Pollen markup file `take1/take1.html.pm`, we have some Racket function definitions starting with ◊, then a bunch of content. Wait, maybe I overstated the difference between Racket code versus content, because what's the difference between
- ``◊(define (emphatic . xs) `(em ,@xs))``, and
- ``◊emphatic{italicize things}``? Or, worse,
- ``◊h1{Take One. Or, Let's Try To Get the Basics.}``?

### Pollen text mode versus Racket mode: Pollen's two syntaxes for calling functions
Here's the first thing you need to know. There's a **one-to-one equivalence** between 
- `◊foo[arg1 arg2]{final-arg}`, which [is called](http://pkg-build.racket-lang.org/doc/pollen/reader.html#%28part._.The_two_command_modes__text_mode___.Racket_mode%29) Pollen text mode, and 
- `◊(foo arg1 arg2 final-arg)` which is Racket mode.

Both call a Racket function `foo`. If the existence of this isomorphism strikes you as pretty freaking amazing, it should, and not just from a theoretical sense. It allows you to treat `foo` as a Racket function using the latter, and as an *equivalent* HTML tag with the former. 

### Pollen forgives undefined functions
The other thing you need to know is also awesome: **if Pollen finds you using functions-tags that you haven't `define`d, it'll treat them as plain HTML tags**. This is why `take1.html.pm` can call `◊h1{Take One …}` without anybody defining `h1` anywhere.

Put the two of these factoids together and you see why we can use `◊span` as 
- a Pollen tag via `◊span['((class "hidden") (id "id1"))]{my span}`, 
- **and** as a Racket function via `◊(span '((class "hidden") (id "id2")) "my other span")`, without explicitly defining `span`.

Of course you can see that, while they're equivalent, in practice it's easier to use one syntax in for some situations and the other for others, if only because you don't need to quote text when you use `◊span{look ma, no quotes!}`.

### Explaining aforementioned usages
Now you can understand those three lines of code above.

``◊(define (emphatic . xs) `(em ,@xs))`` is written using Racket mode syntax, and defines a function called `emphatic` with all arguments rolled into a list called `xs` (just like `def foo(*args)` in Python or `varargin` in other languages), and which returns the input arguments list `xs` prepended with the symbol `em` using a bit of that [quasiquote](http://docs.racket-lang.org/guide/qq.html) magic the Lisp family is famed for.

We invoke this function using `◊emphatic{italicized text}`, and it renders as `<em>italicized text</em>`.

And as Pollen smartly passes through undefined functions as tags, ``◊h1{Take One. Or, Let's Try To Get the Basics.}`` produces the appropriate `<h1>` tag.

Test your understanding: given this `linky` function,
```racket
◊(define (linky url . xs) `(a ((href ,url)) ,@xs))
```
what would
```racket
◊linky["http://github.com"]{slinky dress}
```
render as? You may need to refer to the documentation on [`unquote`](http://docs.racket-lang.org/guide/qq.html) again. Note how this sophomoric implementation prevents `linky` from being given additional attributes like `id` or `class`.

### Templates: packaging it into a tidy HTML file
So in the `take1/` directory, run `$ raco pollen render take1.html`. Unlike other markup translators I've used, Pollen doesn't write to stdout, and will overwrite `take1.html`. For now it can just be opened it in a browser (we'll talk about webservers in a subsequent take). 

You may have noticed, even in the screenshot above, that there is some boilerplate in the rendered HTML that's not in the origial Pollen markup, like `head` and `meta` tags. This comes from a template file, in our case called `take1/template.html`.

This template is also a Pollen file, despite lacking any Pollen-esque file extension. Note a couple of ◊s in it: the first one is just a bit of showing off—the contents of the first `<h1>` tag is grabbed via a Pollen function `select` and used to set the page's `<title>`: `<title>◊select['h1 doc]</title>`. (In Racket mode, this would be `◊(select 'h1 doc)`.) The X-expr `doc` containing the abstract syntax tree (AST) of `take1.html.pm` is available when the template is rendered, which `select` can scan, à la `getElementsByTagName`. 

A bit later, inside a Tufte CSS-specific `<article>` tag, another Pollen function `->html` converts the AST to HTML. This function is clearly tightly intertwined with its target format, but it's illuminating to see an alternative AST-to-output converter: 
```racket
◊(apply string-append (filter string? (flatten doc)))
```
After flattening the nested lists and throwing out tags and attributes, concatenate the strings that remain and you'd have a pretty good *plaintext* representation of `take1.html.pm`.

### Summary of Take One

The functionality demonstrated so far is pretty elementary. The Pollen syntax can seem peculiar, and one couldn't be blamed for being uneasy with the thought of constantly dropping into Racket. Maybe worst of all is we don't have any easy way to *italicize* text like Markdown.

But I am already awestruck by the vistas of flexibility Pollen's approach reveals. Having your document and your template be fully-programmable in the same language dramatically lowers the activation energy for complex document workflows. 

The classic gripe of technical writers with Markdown—its lack of footnotes—can readily be fixed by a couple of quick Racket functions: you could write your paper in Markdown, use Pollen annotations just for the footnotes, and output another Markdown file with footnotes all fancy. But I'd argue that Markdown offers precious little besides single-character markup compared to Pollen markup, hence my advice to throw oneself whole-heartedly on Pollen markup.

In the next take, we'll see how to make Tufte CSS sidenotes and get proper paragraph tags, two much more cognitively burdensome tasks.

## Take Two. Things that appear easier than they are.

… Move the sidenote/splice business here, and include whitespace detection in this take. Take three can be the nginx/push-stream magic.
